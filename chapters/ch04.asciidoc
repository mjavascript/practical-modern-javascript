[[classes-symbols-and-symbols]]
== Classes, Symbols, and Objects

Now that we've covered the basic improvements to the syntax, we're in good shape to take aim at a few other additions to the language: classes, and symbols. Classes provide syntax to represent prototypal inheritance under the traditional class-based programming paradigm. Symbols are a new primitive value type in JavaScript useful for defining protocols, and we'll investigate what that means. When we're done with classes and symbols, we'll discuss a few new static methods added to the +Object+ built-in in ES6.

=== 4.1 Classes

Many features in ES6 such as destructuring are in fact syntactic sugar, and classes are no exception to that. As we know, JavaScript is a prototype-based language, and classes are syntactic sugar on top of prototypical inheritance. In that sense, JavaScript classes don't introduce any fundamental changes to the language: they're merely a different way of declaring object prototypes.

The +class+ keyword acts, then, as a device that makes JavaScript more inviting to programmers coming from other paradigms, who might not be all that familiar with prototype chains.

==== 4.1.1 Class Fundamentals

When learning about new language features, it's always a good idea to look at existing constructs first, and then see how the new feature improves those use cases. We'll start by looking at a simple prototype-based JavaScript constructor and then compare that with the newer classes syntax in ES6.

The code snippet shown below represents a fruit using a constructor function and adding a couple of methods to the prototype. The constructor function takes a +name+ and the amount of +calories+ for a fruit, and defaults to the fruit being in a single piece. There's a +.chop+ method that will slice another piece of fruit, and then there's a +.bite+ method. The +person+ passed into +.bite+ will eat a piece of fruit, getting satiety equal to the remaining calories divided by the amount of fruit pieces left.

[source,javascript]
----
function Fruit (name, calories) {
  this.name = name;
  this.calories = calories;
  this.pieces = 1;
}
Fruit.prototype.chop = function () {
  this.pieces++;
};
Fruit.prototype.bite = function (person) {
  if (this.pieces < 1) {
    return;
  }
  const calories = this.calories / this.pieces;
  person.satiety += calories;
  this.calories -= calories;
  this.pieces--;
};
----

While fairly simple, the piece of code we just put together should be enough to note a few things. We have a constructor function that takes a couple of parameters, a pair of methods, and a number of properties. The next snippet codifies how one should create a +Fruit+ and a +person+ that chops the fruit into four slices and then takes three bites.

[source,javascript]
----
const person = { satiety: 0 };
const apple = new Fruit('apple', 140);
apple.chop();
apple.chop();
apple.chop();
apple.bite(person);
apple.bite(person);
apple.bite(person);
console.log(person.satiety);
// <- 105
console.log(apple.pieces);
// <- 1
console.log(apple.calories);
// <- 35
----

When using +class+ syntax, as shown in the following code listing, the +constructor+ function is declared as an explicit member of the +Fruit+ class, and methods follow the object literal method definition syntax. When we compare the +class+ syntax with the prototype-based syntax, you'll notice we're reducing the amount of boilerplate code quite a bit by avoiding explicit references to +Fruit.prototype+ while declaring methods. The fact that the entire declaration is kept inside the +class+ block also helps the reader understand the scope of this piece of code, making our classes' intent clearer. Lastly, having the constructor explicitly as a method member of +Fruit+ makes the +class+ syntax easier to understand when compared with the prototype-based flavor of class syntax.

[source,javascript]
----
class Fruit {
  constructor (name, calories) {
    this.name = name;
    this.calories = calories;
    this.pieces = 1;
  }
  chop () {
    this.pieces++;
  }
  bite (person) {
    if (this.pieces < 1) {
      return;
    }
    const calories = this.calories / this.pieces;
    person.satiety += calories;
    this.calories -= calories;
    this.pieces--;
  }
};
----

A not-so-minor detail you might have missed is that there aren't any commas in between method declarations of the +Fruit+ class. That's not a mistake our copious copy editors missed, but rather part of the +class+ syntax. The distinction can help avoid mistakes where we treat plain objects and classes as interchangeable even though they're not, and at the same time it makes classes better suited for future improvements to the syntax such as class-scoped private functions.

The class-based solution is equivalent to the prototype-based piece of code we wrote earlier. Consuming a fruit wouldn't change in the slightest, the API for +Fruit+ remains unchanged. The previous piece of code where we instantiated an apple, chopped it into smaller pieces and ate most of it would work well with our +class+ flavored +Fruit+ as well.

It's worth noting that class declarations aren't hoisted to the top of their scope, unlike function declarations. That means you won't be able to instantiate, or otherwise access, a class before its declaration is reached and executed.

[source,javascript]
----
new Person(); // <- ReferenceError: Person is not defined
class Person {
}
----

Besides the class declaration syntax presented above, classes can also be declared as expressions, just like with function declarations and function expressions. You are allowed to omit the name for a +class+ expression, as shown in the following bit of code.

[source,javascript]
----
const Person = class {
  constructor (name) {
    this.name = name;
  }
};
----

Class expressions could be easily returned from a function, making it possible to create a factory of classes with minimal effort. In the following example we create a +Jake+ class dynamically in arrow function which takes a name parameter and then feeds that to the parent +Person+ constructor via +super+.

[source,javascript]
----
const createPersonClass = name => class extends Person {
  constructor () {
    super(name);
  }
};
const Jake = createPersonClass('Jake');
const jake = new Jake();
----

We'll dig deeper into class inheritance later. Let's take a more nuanced look at properties and methods first.

==== 4.1.2 Properties and Methods in Classes

It should be noted that the +constructor+ method declaration is an optional member of a +class+ declaration. The following bit of code is an entirely valid +class+ declaration that's comparable to an empty constructor function.

[source,javascript]
----
class Fruit {
};
// the constructor function below is equivalent to the class above
function Fruit () {
}
----

Any arguments passed to +new Log()+ will be received as parameters to the +constructor+ method for +Log+, as depicted next. You can use those parameters to initialize instances of the class.

[source,javascript]
----
class Log {
  constructor (...args) {
    console.log(args);
  }
};
new Log('a', 'b', 'c');
// <- ['a' 'b' 'c']
----

The following example shows a class where we create and initialize an instance property named +count+ upon construction of each instance. The +get next+ method declaration indicates instances of our +Counter+ class will have a +next+ property that will return the results of calling its method, whenever that property is accessed.

[source,javascript]
----
class Counter {
  constructor (start) {
    this.count = start;
  }
  get next () {
    return this.count++;
  }
};
----

In this case, you could consume the +Counter+ class as shown in the next snippet. Each time the +.next+ property is accessed, the count raises by one. While mildly useful, this sort of use case is usually better suited by methods than by magical +get+ property accessors, and we need to be careful not to abuse property accesors, as consuming an object that abuses of accessors may become very confusing.

[source,javascript]
----
const counter = new Counter(2);
console.log(counter.next);
// <- 2
console.log(counter.next);
// <- 3
console.log(counter.next);
// <- 4
----

When paired with setters, though, accessors may provide an interesting bridge between an object and its underlying data store. Consider the following example where we define a class that can be used to store and retrieve JSON data from +localStorage+ using the provided storage +key+.

[source,javascript]
----
class LocalStorage {
  constructor (key) {
    this.key = key;
  }
  get data () {
    return JSON.parse(localStorage.getItem(this.key));
  }
  set data (data) {
    localStorage.setItem(this.key, JSON.stringify(data));
  }
};
----

Then you could use the +LocalStorage+ class as shown in the next example. Any value that's assigned to +ls.data+ will be converted to its JSON object string representation and stored in +localStorage+. Then, when the property is read from, the same +key+ will be used to retrieve the previously stored contents, parse them as JSON into an object, and returned.

[source,javascript]
----
const ls = new LocalStorage('groceries');
ls.data = ['apples', 'bananas', 'grapes'];
console.log(ls.data);
// <- ['apples', 'bananas', 'grapes']
----

Besides getters and setters, you can also define regular instance methods, as we've explored earlier when creating the +Fruit+ class. The following code example creates a +Person+ class that's able to eat +Fruit+ instances as we had declared them earlier. We then instantiate a fruit and a person, and have the person eat the fruit. The person ends up with a satiety level equal to +40+, because they ate the whole fruit.

[source,javascript]
----
class Person {
  constructor () {
    this.satiety = 0;
  }
  eat (fruit) {
    while (fruit.pieces > 0) {
      fruit.bite(this);
    }
  }
};
const plum = new Fruit('plum', 40);
const person = new Person();
person.eat(plum);
console.log(person.satiety);
// <- 40
----

Sometimes it's also important to have static methods at the class level, rather than at the instance level. JavaScript classes allow you to define such methods using the +static+ keyword, much like you would use +get+ or +set+ as a prefix to a method definition that's a getter or a setter.

The following example defines a +MathHelper+ class with a static +sum+ method that's able to calculate the sum of all numbers passed to it in a function call, by taking advantage of the +Array.prototype.reduce+ method.

[source,javascript]
----
class MathHelper {
  static sum (...numbers) {
    return numbers.reduce((a, b) => a + b);
  }
};
console.log(MathHelper.sum(1, 2, 3, 4, 5));
// <- 15
----

Finally, it's worth mentioning that you could also declare static property accessors, such as getters or setters (+static get+, +static set+). These might come in handy when maintaining global configuration state for a class, or when a class is used under a singleton pattern. Of course, you're probably better off using plain old JavaScript objects at that point, rather than creating a class you never intend to instantiate or only intend to instantiate once. This is JavaScript, a highly dynamic language, after all.

==== 4.1.3 Extending JavaScript Clases

You could use plain JavaScript to extend the +Fruit+ class, but as you will notice by reading the next code snippet, declaring a sub-class involves esoteric knowledge such as +Parent.call(this)+ in order to pass in parameters to the parent class so that we can properly initialize the sub-class, and setting the prototype of the sub-class to an instance of the parent class' prototype. We won't be delving into detailed minutia about these constructs, as you can readily find heaps of information about prototypal inheritance around the web, and our focus in in the newly introduced +class+ syntax anyways.

[source,javascript]
----
function Banana () {
  Fruit.call(this, 'banana', 105);
}
Banana.prototype = Object.create(Fruit.prototype);
Banana.prototype.slice = function () {
  this.pieces = 12;
};
----

Given the ephemeral knowledge one has to remember, and the fact that +Object.create+ was only made available in ES5, JavaScript developers have historically turned to libraries to resolve their prototype inheritance issues. One such example is +util.inherits+ in Node.js, which is usually favored over +Object.create+ for legacy support reasons.

[source,javascript]
----
const util = require('util');
function Banana () {
  Fruit.call(this, 'banana', 105);
}
util.inherits(Banana, Fruit);
Banana.prototype.slice = function () {
  this.pieces = 12;
};
----

Consuming the +Banana+ constructor is no different than how we used +Fruit+, except that the banana has a +name+ and calories already assigned to it, and they come with an extra +slice+ method we can use to promptly chop the banana instance into 12 pieces. The following piece of code shows the +Banana+ in action as we take a bite.

[source,javascript]
----
const person = { satiety: 0 };
const banana = new Banana();
banana.slice();
banana.bite(person);
console.log(person.satiety);
// <- 8.75
console.log(banana.pieces);
// <- 11
console.log(banana.calories);
// <- 96.25
----

Classes consolidate prototypal inheritance, which up until recently had been highly contested in user-space by several libraries trying to make it easier to deal with prototypal inheritance in JavaScript.

The +Fruit+ class is ripe for inheritance. In the following code snippet we create the +Banana+ class as an extension of the +Fruit+ class. Here, the syntax clearly signals our intent and we don't have to worry about thoroughly understanding prototypal inheritance in order to get to the results that we want. When we want to forward parameters to the underlying +Fruit+ constructor, we can use +super+. The +super+ keyword can also be used to call functions in the parent class, such as +super.chop+, and it's not just limited to the constructor for the parent class.

[source,javascript]
----
class Banana extends Fruit {
  constructor () {
    super('banana', 105);
  }
  slice () {
    this.pieces = 12
  }
};
----

Even though the +class+ keyword is static we can still leverage JavaScript's flexible and functional properties when declaring classes. Any expression that returns a constructor function can be fed to +extends+. For example, we could have a constructor function factory and use that as the base class.

The following piece of code has a +createJuicyFruit+ function where we forward the name and calories for a fruit to the +Fruit+ class using a +super+ call, and then all we have to do to create a +Plum+ is extend the intermediary +JuicyFruit+ class.

[source,javascript]
----
const createJuicyFruit = (...params) => class JuicyFruit extends Fruit {
  constructor () {
    this.juice = 0;
    super(...params);
  }
  squeeze () {
    if (this.calories <= 0) {
      return;
    }
    this.calories -= 10;
    this.juice += 3;
  }
};
class Plum extends createJuicyFruit('plum', 30) {
}
----

Let's move onto +Symbol+. While not iteration or flow control mechanism, learning about +Symbol+ is crucial to shaping an understanding of iteration protocols, which are discussed at length later in the chapter.

=== 4.2 Symbols

Symbols are a new primitive type in ES6, and the seventh type in JavaScript. It is an unique value type, like strings and numbers. Unlike strings and numbers, symbols don't have a literal representation such as +'text'+ for strings, or +1+ for numbers. The purpose of symbols is primarily to implement protocols. As we'll learn in section 4.3, the iterable protocol uses a symbol to define how objects are iterated.

There are three flavors of symbols, and each flavor is accessed in a different way. These are: local symbols, created with the +Symbol+ built-in wrapper object and accessed by storing a reference or via reflection; global symbols, created using another API and shared across code realms; and "well-known" symbols, built into JavaScript and used to define internal language behavior.

We'll explore each of these, looking into possible use cases along the way. Let's begin with local symbols.

==== 4.2.1 Local Symbols

Symbols can be created using the +Symbol+ wrapper object. In the following piece of code, we create our +first+ symbol.

[source,javascript]
----
const first = Symbol();
----

While you can use the `new` keyword with +Number+ and +String+, the `new` operator throws a `TypeError` when we try it on `Symbol`. This avoids mistakes and confusing behavior like +new Number(3) !== Number(3)+. The following snippet shows the error being thrown.

[source,javascript]
----
const oops = new Symbol();
// <- TypeError, Symbol is not a constructor
----

For debugging purposes, you can create symbols using a description.

[source,javascript]
----
const mystery = Symbol('my symbol');
----

Like numbers or strings, symbols are immutable. Unlike other value types, however, symbols are unique. As shown in the next piece of code, descriptions don't affect that uniqueness. Symbols created using the same description are also unique and thus different from each other.

[source,javascript]
----
console.log(Symbol() === Symbol());
// <- false
console.log(Symbol('my symbol') === Symbol('my symbol'));
// <- false
console.log(Number(3) === Number(3));
// <- true
----

Symbols are of type +symbol+, new in ES6. The following snippet shows how +typeof+ returns the new type string for symbols.

[source,javascript]
----
console.log(typeof Symbol());
// <- 'symbol'
console.log(typeof Symbol('my symbol'));
// <- 'symbol'
----

Symbols can be used as property keys on objects. Note how you can use a computed property name to avoid an extra statement just to add a +weapon+ symbol key to the +character+ object, as shown in the following example. Note also that, in order to access a symbol property, you'll need a reference to the symbol that was used to create said property.

[source,javascript]
----
const weapon = Symbol('weapon');
const character = {
  name: 'Penguin',
  [weapon]: 'umbrella'
};
console.log(character[weapon]);
// <- 'umbrella'
----

Keep in mind that symbol keys are hidden from many of the traditional ways of pulling keys from an object. The next bit of code shows how +for..in+, +Object.keys+, and +Object.getOwnPropertyNames+ fail to report on symbol properties.

[source,javascript]
----
for (key in character) {
  console.log(key);
  // <- 'name'
}
console.log(Object.keys(character));
// <- ['name']
console.log(Object.getOwnPropertyNames(character));
// <- ['name']
----

This aspect of symbols means that code that was written before ES6 and without symbols in mind won't unexpectedly start stumbling upon symbols. In a similar fashion, as shown next, symbol properties are discarded when representing an object as JSON.

[source,javascript]
----
console.log(JSON.stringify(character));
// <- '{"name":"Penguin"}'
----

That being said, symbols are by no means a safe mechanism to conceal properties. Even though you won't stumble upon symbol properties when using reflection or serialization methods, symbols are revealed by a dedicated method as shown in the next snippet of code. In other words, symbols are not non-enumerable, but hidden in plain sight. Note that +Object.getOwnPropertySymbols+

[source,javascript]
----
console.log(Object.getOwnPropertySymbols(character));
// <- [Symbol(weapon)]
----

Now that we've established how symbols work. What can we use them for?

==== 4.2.2 Practical use cases for Symbols

Symbols could be used by a library to map objects to DOM elements. For example, a library that needs to associate the API object for a calendar to the provided DOM element. Before ES6, there wasn't a clear way of mapping DOM elements to objects. You could add a property to a DOM element pointing to the API, but polluting DOM elements with custom properties is a bad practice. You have to be careful to use property keys that won't be used by other libraries, or worse, by the language itself in the future. That leaves you with using an array lookup table containing an entry for each DOM/API pair. That, however, might be slow in long-running applications where the array lookup table might grow in size, slowing down the lookup operation over time.

Symbols, on the other hand, don't have these problem. They can be used as properties that don't have a risk of clashing with future language features, as they're unique. The following code snippet shows how a symbol could be used to map DOM elements into calendar API objects.

[source,javascript]
----
const cache = Symbol('calendar');
function createCalendar (el) {
  if (cache in el) { // check if the symbol exists in the element
    return el[cache]; // use the cache to avoid re-instantiation
  }
  const api = el[cache] = {
    // the calendar API goes here
  };
  return api;
}
----

A +WeakMap+ is an ES6 built-in that can be used to efficiently map objects to other objects without using regular properties, symbol properties, or arrays. In contrast with array lookup tables, +WeakMap+ is O(1), just like using symbol properties. The +WeakMap+ couldn't be accessed from outside the library unless explicitly exposed, unlike with symbols which can be accessed through +Object.getOwnPropertySymbols+. We'll explore +WeakMap+ in chapter 5, alongside other ES6 collection built-ins.

===== Defining Protocols through Symbols

Earlier, we posited that a use case for symbols is to define protocols. A protocol is a communication contract or convention that defines behavior. In less abstract terms, a library could use a symbol that could then be used by objects that adhere to a convention from the library.

Consider the following bit of code, where we use the special +toJSON+ method to determine the object serialized by +JSON.stringify+. As you can see, stringifying the +character+ object produces a serialized version of the object returned by +toJSON+.

[source,javascript]
----
const character = {
  name: 'Thor',
  toJSON: () => ({
    key: 'value'
  })
};
console.log(JSON.stringify(character));
// <- '"{"key":"value"}"'
----

In contrast, if +toJSON+ was anything other than a function, the original +character+ object would be serialized, including the +toJSON+ property, as shown next. This sort of inconsistency ensues from relying on regular properties to define behavior.

[source,javascript]
----
const character = {
  name: 'Thor',
  toJSON: true
};
console.log(JSON.stringify(character));
// <- '"{"name":"Thor","toJSON":true}"'
----

The reason why it would be better to implement the +toJSON+ modifier as a symbol is that that way it wouldn't interfere with other object keys. Given that symbols are unique, never serialized, and never exposed unless explicitly requested through +Object.getOwnPropertySymbols+, they would represent a better choice when defining a contract between +JSON.stringify+ and how objects want to be serialized. Consider the following piece of code with an alternative implementation of +toJSON+ using a symbol to define serialization behavior for a +stringify+ function.

[source,javascript]
----
const json = Symbol('alternative to toJSON');
const character = {
  name: 'Thor',
  [json]: () => ({
    key: 'value'
  })
};
stringify(character);
function stringify (target) {
  if (json in target) {
    return JSON.stringify(target[json]());
  }
  return JSON.stringify(target);
}
----

Using a symbol means we need to use a computed property name to define the +json+ behavior directly on an object literal. It also means that the behavior won't clash with other user-defined properties or upcoming language features we couldn't foresee. Another difference is that the +json+ symbol should be available to consumers of the +stringify+ function, so that they can define their own behavior. We could easily add the following line of code to expose the +json+ symbol directly through +stringify+, as shown below. That'd also tie the +stringify+ function with the symbol that modifies its behavior.

[source,javascript]
----
stringify.as = json;
----

By exposing the +stringify+ function we'd be exposing the +stringify.as+ symbol as well, allowing consumers to tweak behavior by minimally modifying objects, using the custom symbol.

When it comes to the merits of using a symbol to describe behavior, as opposed to an option passed as to the +stringify+ function, there's a few considerations to keep in mind. First, adding option parameters to a function changes its public API, whereas changing the internal implementation of the function to support another symbol wouldn't affect the public API. Using an +options+ object with different properties for each option mitigates this effect, but it's not always convenient to require an +options+ object in every function call.

A benefit of defining behavior via symbols is that you could augment and customize the behavior of objects without changing anything other than the value assigned to a symbol property and perhaps the internal implementation of the piece of code that leverages that behavior. The benefit of using symbols over properties is that you're not subject to name clashes when new language features are introduced.

Besides local symbols, there's also a global symbol registry, accessible from across code realms. Let's look into what that means.

==== 4.2.3 Global Symbol Registry

A code realm is any JavaScript execution context, such as the page your application is running in, an +<iframe>+ within that page, an script running through +eval+, or a worker of any kind -- such as web workers, service workers, or shared workers. Each of these execution contexts has its own global object. Global variables defined on the +window+ object of a page, for example, aren't available to a +ServiceWorker+. In contrast, the global symbol registry is shared across all code realms.

There's two methods that interact with the runtime-wide global symbol registry: +Symbol.for+ and +Symbol.keyFor+. What do they do?

===== Getting symbols with +Symbol.for(key)+

The +Symbol.for(key)+ method looks up +key+ in the runtime-wide symbol registry. If a symbol with the provided +key+ exists in the global registry, that symbol is returned. If no symbol with that +key+ is found in the registry, one is created and added to the registry under the provided +key+. That's to say, +Symbol.for(key)+ is idempotent: it looks for a symbol under a +key+, creates one if it didn't already exist, and then returns the symbol.

In the following code snippet, the first call to +Symbol.for+ creates a symbol identified as +'example'+, adds it to the registry, and returns it. The second call returns that same symbol because the +key+ is already in the registry -- and associated to the symbol returned by the first call.

[source,javascript]
----
const example = Symbol.for('example');
console.log(example === Symbol.for('example'));
// <- true
----

That contrasts with what we knew about symbols being unique. The global symbol registry keeps track of symbols by their +key+. Note that the +key+ will also be used as a +description+ when the symbols that go into the registry are created. Considering these symbols are global on a runtime-wide level, you might want to prefix symbol keys in the global registry with a value that identifies your library or component, mitigating potential name clashes.

===== Using +Symbol.keyFor(symbol)+ to retrieve symbol keys

Given a symbol +symbol+, +Symbol.keyFor(symbol)+ returns the +key+ that was associated with +symbol+ when the symbol was added to the global registry. The next example shows how we can grab a the +key+ for a +symbol+ using +Symbol.keyFor+.

[source,javascript]
----
const example = Symbol.for('example');
console.log(Symbol.keyFor(example));
// <- 'example'
----

Note that if the symbol isn't in the global runtime registry, then the method returns +undefined+.

[source,javascript]
----
console.log(Symbol.keyFor(Symbol()));
// <- undefined
----

Also keep in mind that it's not possible to match symbols in the global registry usign local symbols, even when they share the same description. The reason for that is that local symbols aren't part of the global registry, as shown in the following piece of code.

[source,javascript]
----
const example = Symbol.for('example');
console.log(Symbol.keyFor(Symbol('example')));
// <- undefined
----

Now that you've learned about the API for interacting with the global symbol registry, let's take some considerations into account.

===== Best Practices and Considerations

A runtime-wide registry means the symbols are accessible across code realms. The global registry returns a reference to the same object in any realm the code runs in. In the following example, we demonstrate how the +Symbol.for+ API returns the same symbol in a page and within an +<iframe>+.

[source,javascript]
----
const d = document;
const frame = d.body.appendChild(d.createElement('iframe'));
const framed = frame.contentWindow;
const s1 = window.Symbol.for('example');
const s2 = framed.Symbol.for('example');
console.log(s1 === s2);
// <- true
----

There's tradeoffs in using widely available symbols. On the one hand, they make it easy for libraries to expose their own symbols, but on the other hand they could also expose their symbols on their own API, using local symbols. The symbol registry is obviously useful when symbols need to be shared across any two code realms, for example: +ServiceWorker+ and a web page. The API is also convenient when you don't want to bother storing references to the symbols, you could use the registry directly for that, since every call with a given +key+ is guaranteed to return the same +symbol+. You'll have to keep in mind, though, that these symbols are shared across the runtime and that might lead to unwanted consequences if you use generic symbol names like +each+ or +contains+.

There's one more kind of symbols, the built-in well-known symbols.

==== 4.2.4 Well-known Symbols

So far we've covered symbols you can create using the +Symbol+ function and those you can create through +Symbol.for+. The third and last kind of symbols we're going to cover is the well-known symbols. These are built into the language instead of created by the user, and they provide hooks into internal language behavior allowing you to extend or customize aspects of the language that weren't accessible prior to ES6.

A great example of how symbols can add extensibility to the language without breaking existing code is the +Symbol.toPrimitive+ well-known symbol. It can be assigned a function to determine how an object is casted into a primitive value. The function receives a +hint+ parameter that can be +'string'+, +'number'+, or +'default'+, indicating what type of primitive value is expected.

[source,javascript]
----
const morphling = {
  [Symbol.toPrimitive](hint) {
    if (hint === 'number') {
      return Infinity;
    }
    if (hint === 'string') {
      return 'a lot';
    }
    return '[object Morphling]';
  }
};
console.log(+morphling);
// <- Infinity
console.log(`That is ${morphling}!`);
// <- 'That is a lot!'
console.log(morphling + ' is powerful');
// <- '[object Morphling] is powerful'
----

Another example of a well-known symbol is +Symbol.match+. A regular expression that sets +Symbol.match+ to +true+ will be treated as a string literal when passed to +.startsWith+, +.endsWith+, or +.includes+. These three functions are new string methods in ES6. First we have +.startsWith+, which can be used to determine if the string starts with another string. Then there's +.endsWith+, that finds out whether the string ends in another one. Lastly, the +.includes+ method returns +true+ if a string contains another one. The next snippet of code shows how +Symbol.match+ can be used to compare a string with the string representation of a regular expression.

[source,javascript]
----
const text = '/an example string/';
const regex = /an example string/;
regex[Symbol.match] = false;
console.log(text.startsWith(regex));
// <- true
----

If the regular expression wasn't modified through the symbol, it would've thrown because the +.startsWith+ method expects a string instead of a regular expression.

===== Shared across realms but not in the registry

Well-known symbols are shared across realms. The following example shows how +Symbol.iterator+ is the same reference as that within the context of an +<iframe>+ window.

[source,javascript]
----
const frame = document.createElement('iframe');
document.body.appendChild(frame);
console.log(Symbol.iterator === frame.contentWindow.Symbol.iterator);
// <- true
----

Note that even though well-known symbols are shared across code realms, they're not in the global registry. The following bit of code shows that +Symbol.iterator+ produces +undefined+ when we ask for its +key+ in the registry. That means the symbol isn't listed in the global registry.

[source,javascript]
----
console.log(Symbol.keyFor(Symbol.iterator));
// <- undefined
----

One of the most useful well-known symbols is +Symbol.iterator+, used by a few different language constructs to iterate over a sequence, as defined by a function assigned to a property using that symbol on any object. In the next chapter we'll go over +Symbol.iterator+ in detail, using it extensively along with the iterator and iterable protocols.

=== 4.3 Object Built-in Improvements

While we've already addressed syntax enhancements coming to object literals in chapter 3, there's a few new static methods available to the +Object+ built-in which we haven't addressed yet. It's time to take a look at what these methods bring to the table.

We've already looked at +Object.getOwnPropertySymbols+, but let's also take a look at +Object.assign+, +Object.is+, and +Object.setPrototypeOf+.

==== 4.3.1 Extending objects with +Object.assign+

The need to provide default values for a configuration object is not at all uncommon. Typically, libraries and well-designed component interfaces come with sensible defaults that cater to the most frequented use cases.

A Markdown library, for example, might convert Markdown into HTML by providing only an +input+ parameter. That's its most common use case, simply parsing Markdown, and so the library doesn't demand that the consumer provides any options. The library might, however, support many different options that could be used to tweak its parsing behavior. It could have an option to allow +<script>+ or +<iframe>+ tags, or an option to highlight keywords in code snippets using CSS.

Imagine, for example, that you want to provide a set of defaults like the one shown next.

[source,javascript]
----
const defaults = {
  scripts: false,
  iframes: false,
  highlightSyntax: true
};
----

One possibility would be to use the +defaults+ object as the default value for the +options+ parameter, using destructuring. In this case, the user must provide values for every option whenever they decide to provide any options at all.

[source,javascript]
----
function md (input, options=defaults) {
}
----

The default values have to be merged with user-provided configuration, somehow. That's where +Object.assign+ comes in, as shown in the following example. Here, we start with an empty +{}+ object, copy our default values over to it, and then copy the options on top. The resulting +config+ object will have all of the default values plus the user-provided configuration.

[source,javascript]
----
function md (input, options) {
  const config = Object.assign({}, defaults, options);
}
----

For any properties that had a default value where the user also provided a value, the user-provided value will prevail. Here's how +Object.assign+ works. First, it takes the first argument passed to it, let's call it +target+. It then iterates over all keys of each of the other arguments, let's call them +sources+. For each source in +sources+, all of its properties are iterated and assigned to +target+. The end result is that right-most sources -- in our case, the +options+ object -- overwrite any previously assigned values, as shown in the following bit of code.

[source,javascript]
----
const defaults = {
  first: 'first',
  second: 'second'
};
function print (options) {
  console.log(Object.assign({}, defaults, options));
}
print();
// <- { first: 'first', second: 'second' }
print({ third: 3 });
// <- { first: 'first', second: 'second', third: 3 }
print({ second: false });
// <- { first: 'first', second: false }
----

Before +Object.assign+ made its way into the language, there were numerous similar implementations of this technique in user-land JavaScript, with names like assign, or extend. Adding +Object.assign+ to the language consolidates these options into a single method.

Note, however, that +Object.assign+ doesn't cater to every need. While most user-land implementations have the ability to perform deep assignment, +Object.assign+ doesn't offer a recursive treatment of objects. Object values are assigned as properties on +target+ directly, instead of being recursively assigned key by key.

In the following bit of code you might expect the +f+ property to be added to +target.a+ while keeping +b.c+ and +b.d+ intact, but the +b.c+ and +b.d+ properties are lost when using +Object.assign+.

[source,javascript]
----
Object.assign({}, { a: { b: 'c', d: 'e' } }, { a: { f: 'g' } });
// <- { a: { f: 'g' } }
----

In the same vein, arrays don't get any special treatment either. If you expected recursive behavior in +Object.assign+ the following snippet of code may also come as a surprise, where you may have expected the resulting object to have +'d'+ in the third position of the array.

[source,javascript]
----
Object.assign({}, { a: ['b', 'c', 'd'] }, { a: ['e', 'f'] });
// <- { a: ['e', 'f'] }
----

You could also use a library like +assignment+ on npm, which always performs assignments recursively, the +.extend+ method in jQuery, or a custom version of +_.assignWith+ in Lodash.

==== 4.3.2 Comparing objects with +Object.is+

The +Object.is+ method is a slightly different version of the strict equality comparison operator, +===+. For the most part, +Object.is(a, b)+ is equal to +a === b+. There are two differences: the case of +NaN+ and the case of +-0+ and ++0+.

When +NaN+ is compared to +NaN+, the strict equality comparison operator returns +false+ because +NaN+ is not equal to itself. The +Object.is+ method, however, returns +true+ in this special case.

[source,javascript]
----
NaN === NaN
// <- false
Object.is(NaN, NaN);
// <- true
----

Similarly, when +-0+ is compared to ++0+, the +===+ operator produces +true+ while +Object.is+ returns +false+.

[source,javascript]
----
-0 === +0
// <- true
Object.is(-0, +0);
// <- false
----

These differences may not seem like much, but dealing with +NaN+ has always been cumbersome because of its special quirks, such as +typeof NaN+ being +'number'+ and it not being equal to itself.

==== 4.3.3 +Object.setPrototypeOf+

The +Object.setPrototypeOf+ method does exactly what its name conveys: it sets the prototype of an object to a reference to another object. It's considered the proper way of setting the prototype, as opposed to using +__proto__+ which is a legacy feature.

Before ES6, we were introduced to +Object.create+ in ES5. Using that method, we could create an object based on any prototype passed into +Object.create+, as shown next.

[source,javascript]
----
const baseCat = { type: 'cat', legs: 4 };
const cat = Object.create(baseCat);
cat.name = 'Milanesita';
----

The +Object.create+ method is, however, limited to newly created objects. In contrast, we could use +Object.setPrototypeOf+ to change the prototype of an object that already exists, as shown in the following code snippet.

[source,javascript]
----
const baseCat = { type: 'cat', legs: 4 };
const cat = Object.setPrototypeOf({ name: 'Milanesita' }, baseCat);
----

Note however that there are serious performance implications when using +Obect.setPrototypeOf+ as opposed to +Object.create+, and some careful consideration is in order before you decide to go ahead and sprinkle +Object.setPrototypeOf+ all over a codebase.

.Performance issues
[WARNING]
====
Using +Object.setPrototypeOf+ to change the prototype of an object is an expensive operation. Here is what the Mozilla Developer Network documentation has to say about the matter.

[quote, Mozilla Developer Network]
____
Changing the prototype of an object is, by the nature of how modern JavaScript engines optimize property accesses, a very slow operation, in every browser and JavaScript engine. The effects on performance of altering inheritance are subtle and far-flung, and are not limited to simply the time spent in a +obj.__proto__ = ...+ statement, but may extend to any code that has access to any object whose prototype has been altered. If you care about performance you should avoid setting the prototype of an object. Instead, create a new object with the desired prototype using +Object.create()+.
----
====
