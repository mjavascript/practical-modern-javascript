[[ecmascript6-essentials]]
== ES6 Essentials

The sixth edition of the language comes with a plethora of non-breaking syntax improvements, most of which we'll tackle throughout this chapter. Many of these changes are syntactic sugar, that is: they could be represented in ES5, albeit using more complicated pieces of code. There's also changes in variable declaration that aren't syntactic sugar but instead a completely different way of declaring variables using +let+ and +const+, as we'll see towards the end of the chapter.

Object literals get a few syntax changes in ES6, and they're a good place to start.

=== 3.1 Object Literals

An object literal is any object declaration using the +{}+ shorthand syntax, such as the following example.

[source,javascript]
----
var book = {
  title: 'Modular ES6',
  author: 'Nicolas',
  publisher: 'O´Reilly'
};
----

There's three improvements coming to object literal syntax in ES6: property value shorthands, computed property names, and method definitions. Let's go through them and describe their use cases as well.

==== 3.1.1 Property Value Shorthands

Whenever you find yourself declaring a property whose value is a reference to a variable by the same name, you can omit the property value. It's implicit in ES6, as shown in the following example.

[source,javascript]
----
var listeners = [];
function listen () {}
var api = { listeners, listen };
----

As we'll further explore in the second part of the book, property value shorthands help de-duplicate the code we write without dilluting its meaning. In the following snippet I re-implemented part of +localStorage+, a browser API for persistent storage, as an in-memory polyfill. If it weren't for the shorthand syntax, the +api+ object would be more verbose to type out.

[source,javascript]
----
var store = {};
var api = { getItem,  setItem, clear };
function getItem (key) {
  return key in store ? store[key] : null;
}
function setItem (key, value) {
  store[key] = value;
}
function clear () {
  store = {};
}
----

That's the first of many ES6 features that are aimed towards reducing complexity in the code you have to maintain. Once you get used to the syntax, you'll notice that code readability and developer productivity get boosts as well.

==== 3.1.2 Computed Property Names

Sometimes you have to declare objects that contain properties with names based on variables or other JavaScript expressions, as shown in the following piece of code written in ES5. For this example, assume that +expertise+ is provided to you as a function parameter, and is not a value you know beforehand.

[source,javascript]
----
var expertise = 'journalism';
var person = {
  name: 'Sharon',
  age: 27
};
person[expertise] = {
  years: 5,
  interests: ['international', 'politics', 'internet']
};
----

Object literals in ES6 aren't constrained to declarations with static names. With computed property names, you can wrap any expression in square brackets, and use that as the property name. When the declaration is reached, your expression is evaluated and used as the property name. The following example shows how the piece of code we just saw could declare the person object in a single step, without having to resort to a second statement adding the person's +expertise+.

[source,javascript]
----
var expertise = 'journalism';
var person = {
  name: 'Sharon',
  age: 27,
  [expertise]: {
    years: 5,
    interests: ['international', 'politics', 'internet']
  }
};
----

You can't combine the property value shorthands with computed property names. Value shorthands are simple compile-time syntactic sugar that helps avoid repetition, while computed name expressions are evaluated at runtime. Given that we're trying to mix these two incompatible features, the following example would throw a syntax error. In most cases this combination would lead to code that's hard to interpret for other humans, so it's probably a good thing that you can't combine the two.

[source,javascript]
----
var expertise = 'journalism';
var journalism = {
  years: 5,
  interests: ['international', 'politics', 'internet']
};
var person = {
  name: 'Sharon',
  age: 27,
  [expertise]
};
----

A common scenario for computed property names is when we want to add an entity to an object map that uses the +entity.id+ field as its keys, as shown next. Instead of having to have a third statement where we add the +grocery+ to the +groceries+ map, we can inline that declaration in the +groceries+ object literal itself.

[source,javascript]
----
var grocery = {
  id: 'bananas',
  name: 'Bananas',
  units: 6,
  price: 10,
  currency: 'USD'
};
var groceries = {
  [grocery.id]: grocery
};
----

Another case may be whenever a function receives a parameter that it should then use to build out an object. In ES5 code, you'd need to allocate a variable declaring an object literal, then add the dynamic property, and then return the object. The following example shows exactly that, when creating an envelope that could later be used for AJAX messages which follow a convention: they have an +error+ property with a description when something goes wrong, and a +success+ property when things turn out okay.

[source,javascript]
----
function getEnvelope (type, description) {
  var envelope = {
    data: {}
  };
  envelope[type] = description;
  return envelope;
}
----

Computed property names help us write the same function more concisely, using a single statement.

[source,javascript]
----
function getEnvelope (type, description) {
  return {
    data: {},
    [type]: description
  };
}
----

The last enhancement coming to object literals is about functions.

==== 3.1.3 Method Definitions

Typically, you can declare methods on an object by adding properties to it, as shown in the next snippet.

[source,javascript]
----
var emitter = {
  emit: function (eventName) {
  }
};
----

Property getters and setters, in contrast, have a different syntax. In this case, there's no need for the +function+ keyword, and no colons are involved. Getters are prefixed by +get+ and setters are prefixed with +set+. Then there's the property name, a list of parameters, and the method body. The next example shows a simple object that defines a getter and a setter.

[source,javascript]
----
var reserves = 4;
var spaceship = {
  get fuel () {
    return reserves;
  },
  set fuel (value) {
    reserves = value;
  }
};
----

Starting in ES6, you can declare regular methods on an object literal using a similar syntax. The only difference is that you need to omit a prefix like +get+ and +set+. This syntax complements getters and setters while providing a terse alternative to traditional method declarations where you need to use the +function+ keyword. The following example shows a method definition using the ES6 syntax alongside the rest of our +spaceship+ object.

[source,javascript]
----
var reserves = 4;
var spaceship = {
  get fuel () {
    return reserves;
  },
  set fuel (value) {
    reserves = value;
  },
  deplete () {
    reserves = 0;
  }
};
spaceship.fuel = 10;
spaceship.deplete();
----

One problem with this syntax is that it tightly couples a method to an object. While that's fine for getters and setters, it might not be okay for other methods. In terms of modular design, it would be cleaner to keep your code decoupled, and the syntax discourages it. By dropping the +function+ keyword and inferring the property name from the method, we are making it hard to extract +deplete+ from the object literal.

Arrow functions are another way of declaring functions in ES6, and they come in several flavors. Let's investigate what arrow functions are, how they can be declared, and how they behave semantically.

=== 3.2 Arrow Functions

In JavaScript you typically declare functions using code like the following, where you have a name, a list of parameters, and a function body.

[source,javascript]
----
function name (parameters) {
  // function body
}
----

You could also create anonymous functions, by omitting the name, when assigning the function to a variable, a property, or a function call.

[source,javascript]
----
var example = function (parameters) {
  // function body
};
----

Starting with ES6, you can use arrow functions as another way of writing anonymous functions. Keep in mind, there's several slightly different ways of writing them. The following piece of code shows an arrow function that's very similar to the anonymous function we just saw. The only difference seems to be the missing +function+ keyword and the +=>+ arrow to the right of the parameter list.

[source,javascript]
----
var example = (parameters) => {
  // function body
};
----

While arrow functions look very similar to your typical anonymous function, they are fundamentally different: arrow functions can't have a name, and they are bound to their lexical scope. Let's dig into their semantic differences with traditional functions, the many ways to declare an arrow function, and practical use cases.

==== 3.2.1 Lexical Scoping

In the body of an arrow function, +this+ and +arguments+ both point to the containing scope. Consider the following example. We have a +timer+ object with a +seconds+ counter and a +start+ method defined using the syntax we've learned about earlier. We then start the timer, wait for a few seconds, and log the current amount of ellapsed +seconds+.

[source,javascript]
----
var timer = {
  seconds: 0,
  start () {
    setInterval(() => {
      this.seconds++;
    }, 1000);
  }
};
timer.start();
setTimeout(function () {
  console.log(timer.seconds)
}, 3500);
// <- 3
----

If we had defined the function passed to +setInterval+ as a regular anonymous function instead of using an arrow function, +this+ would've been bound to the context of the anonymous function, instead of the context of the +start+ method. We could have implemented +timer+ with a declaration like +var self = this+ at the beginning of the +start+ method, and then referencing +self+ instead of +this+. With arrow functions, the added complexity of keeping context references around fades away and we can focus on the functionality of our code.

In a similar fashion, lexical binding in ES6 arrow functions also means that function calls won't be able to change the +this+ context when using +.call+, +.apply+, +.bind+, etc. Usually, that limitation is more of a feature than a bug.

I've mentioned there's several flavors of arrow functions, but so far we've only looked at their fully fleshed version. What are the others way to represent an arrow function?

==== 3.2.2 Arrow Function Flavors

Let's look one more time at the arrow function syntax we've learned so far.

[source,javascript]
----
var example = (parameters) => {
  // function body
};
----

An arrow function with exactly one parameter can omit the parenthesis. This is optional. It's useful when passing the arrow function to another method, as it reduces the amount of parenthesis involved, making it easier for humans to parse the code.

[source,javascript]
----
var double = value => {
  return value * 2;
};
----

Arrow functions are heavily used for simple functions, such as the +double+ function we just saw. The following flavor of arrow functions does away with the function body. Instead, you provide an expression such as +value * 2+. When the function is called, the expression is evaluated and its result is returned. The +return+ statement is implicit, and there's no need for brackets denoting the function body anymore, as you can only use a single expression.

[source,javascript]
----
var double = (value) => value * 2;
----

Note that you can combine implicit parenthesis and implicit return, making for concise arrow functions.

[source,javascript]
----
var double = value => value * 2;
----

.Implicitly Returning Object Literals
****
When you need to implicitly return an object literal, you'll need to wrap that object literal expression in parenthesis. Otherwise, the compiler would interpret your brackets as the start and the end of the function block.

[source,javascript]
----
var objectFactory = () => ({ modular: 'es6' });
----

In the following example, JavaScript interprets +number+ as a label and then figures out we have a +value+ expression that doesn't do anything. Since we're in a block and not returning anything, the mapped values will be +undefined+.

[source,javascript]
----
[1, 2, 3].map(value => { number: value })
// <- [undefined, undefined, undefined]
----

If our attempt at implicitly returning an object literal had more than a single property, then the compiler wouldn't be able to make sense of the second property, and it'd throw a +SyntaxError+.

[source,javascript]
----
[1, 2, 3].map(value => { number: value, verified: true })
// <- SyntaxError
----

Wrapping the expression in parenthesis fixes these issues, because the compiler would no longer interpret it as a function block. Instead, the object declaration becomes an expression that evaluates to the object literal we want to return implicitly.

[source,javascript]
----
[1, 2, 3].map(value => ({ number: value, verified: true }))
/* <- [
  { number: 1, verified: true },
  { number: 2, verified: true },
  { number: 3, verified: true }]
*/
----
****

Now that you understand arrow functions, let's ponder about their merits and where they might be a good fit.

==== 3.2.3 Merits and Use Cases

As a rule of thumb, you shouldn't blindly adopt ES6 features wherever you can. Instead, it's best to reason about each case individually and see whether adopting the new feature actually improves code readibility and maintainability. ES6 features are not strictly better than what we had all along, and it's a bad idea to treat them as such.

There's a few situations where arrow functions may not be the best tool. For example, if you have a large function with several lines of code, replacing +function+ for +=>+ is hardly going to improve your code. Keep in mind that arrow functions are strictly anonymous: they can't have a name. Naming a function properly might add enough context to make it easier for humans to interpret.

Arrow functions are neat when it comes to defining anonymous functions that should probably be lexically bound anyways, and they can definitely make your code more terse in some situations. They are particularly useful in most functional programming situations such as when using +.map+, +.filter+, or +.reduce+ on collections, as shown in the following example.

[source,javascript]
----
[1, 2, 3, 4]
  .map(value => value * 2)
  .filter(value => value > 2)
  .forEach(value => console.log(value))
// <- 4
// <- 6
// <- 8
----

The next feature we'll analyze is destructuring in assignment. Let's see what that's all about.

=== 3.3 Assignment Destructuring

This is one of the most flexible and expressive features in ES6. It's also one of the simplest. It binds properties to as many variables as you need. It works with objects, arrays, and even in +function+ parameter lists. Let's go step by step, starting with objects.

==== 3.3.1 Destructuring Objects

Imagine you had a program with some comic book characters, Bruno Diaz being one of them, and you want to refer to properties in the object that describes him. Here's the example object we'll be using for Batman.

[source,javascript]
----
var character = {
  name: 'Bruno',
  pseudonym: 'Batman',
  metadata: {
    age: 34,
    gender: 'male'
  },
  batarang: ['gas pellet', 'bat-mobile control', 'bat-cuffs']
};
----

If you wanted a +pseudonym+ variable referencing +character.batman+, you could write the following bit of ES5 code. This is commonplace when, for instance, you'll be referencing +pseudonym+ in several places in your codebase and you'd prefer to avoid typing out +character.pseudonym+ each time.

[source,javascript]
----
var pseudonym = character.pseudonym;
----

With destructuring in assignment, the syntax becomes a bit more clear. As you can see in the next example, you don't have to write +pseudonym+ twice, while still clearly conveying intent. The following statement is equivalent to the previous one written in ES5 code.

[source,javascript]
----
var { pseudonym } = character;
----

Just like you could declare multiple comma-separated variables with a single +var+ statement, you can also declare multiple variables within the brackets of a destructuring expression.

[source,javascript]
----
var { pseudonym, name } = character;
----

In a similar fashion, you could mix and match destructuring with regular variable declarations in the same +var+ statement. While this might look a bit confusing at first, it'll be up to any JavaScript coding style guides you follow to determine whether it's appropriate to declare several variables in a single statement. In any case, it goes to show the flexibility offered by destructuring syntax.

[source,javascript]
----
var { pseudonym, name } = character, two = 2;
----

If you want to extract a property named +pseudonym+ but would like to declare it as a variable named +alias+, you can use the following destructuring syntax known as aliasing. Note that you can use +alias+ or any other valid variable name.

[source,javascript]
----
var { pseudonym: alias } = character;
console.log(alias);
// <- 'Batman'
----

While aliases don't look any simpler than the ES5 flavor, +alias = character.pseudonym+, they start making sense when you consider the fact that destructuring supports deep structures as in the following example.

[source,javascript]
----
var { metadata: { gender } } = character;
----

In cases like the previous one, where you have deeply nested properties being destructured, you might be able to convey a property name more clearly if you choose an alias. Consider the next snippet, where a property named +code+ wouldn't have been as indicative of its contents as +colorCode+ could be.
[source,javascript]
----
var palette = {
  color: {
    name: 'Red',
    code: '#f00'
  }
};
var { color: { code: colorCode } } = palette;
----

The scenario we just saw repeats itself frequently, because properties are often named in the context of their host object. While +palette.color.code+ is perfectly descriptive, +code+ on its own could mean a wide variety of things, and aliases such as +colorCode+ can help you bring context back into the variable name while still using destructuring.

Whenever you access an inexistent property in ES5 notation, you get a value of +undefined+.

[source,javascript]
----
console.log(character.boots);
// <- undefined
console.log(character['boots']);
// <- undefined
----

With destructuring, the same behavior prevails. When declaring a destructured variable for a property that's missing, you'll get back +undefined+ as well.

[source,javascript]
----
var { boots } = character;
console.log(boots);
// <- undefined
----

A destructured declaration accessing a nested property of a parent object that's +null+ or +undefined+ will throw an +Exception+, just like regular attempts to access properties of +null+ or +undefined+ would, in other cases.

[source,javascript]
----
var { batmobile: { gear } } = character;
// <- Exception
var { missing } = null;
// <- Exception
----

When you think of that piece of code as the equivalent ES5 code shown next, it becomes evident why the expression must throw, given that destructuring is mostly syntactic sugar.

[source,javascript]
----
var nothing = null;
var missing = nothing.missing;
// <- Exception
----

As part of destructuring, you can provide default values for those cases where the value is +undefined+. The default value can be anything you can think of: numbers, strings, functions, objects, a reference to another variable, etc.

[source,javascript]
----
var { boots = true } = character;
console.log(boots);
// <- true
----

Default values can also be provided in nested property destructuring.

[source,javascript]
----
var { metadata: { enemy = 'Satan' } } = character;
console.log(enemy);
// <- 'Satan'
----

For use in combination with aliases, you should place the alias first, and then the default value, as shown next.

[source,javascript]
----
var { boots: footwear = true } = character;
----

It's possible to mix destructuring with computed property names. In this case, however, you're required to provide an alias to be used as the variable name. That's because computed property names allow arbitrary expressions and thus the compiler isn't always able to infer a variable name.

[source,javascript]
----
var person = { scientist: true };
var type = 'scientist';
var { [type]: value } = person;
console.log(value);
// <- true
----

This flavor of destructuring is probably the least useful, as +value = person[type]+ is easier to read than +{ [type]: value } = person+. That being said, it could still be useful in a few deep destructuring scenarios.

That's it, as far as objects go, in terms of destructuring. What about arrays?

==== 3.3.2 Destructuring Arrays

The syntax for destructuring arrays is similar to that of objects. The following example shows a +coordinates+ object that's destructured into two variables: +x+ and +y+. Note how the notation uses square brackets instead of curly braces, this denotes we're using array destructuring instead of object destructuring. Instead of having to sprinkle your code with implementation details like +x = coordinates[0]+, with destructuring you can convey your meaning clearly and without explicitly referencing the indices, naming the values instead.

[source,javascript]
----
var coordinates = [12, -7];
var [x, y] = coordinates;
console.log(x);
// <- 12
----

When destructuring arrays, you can skip uninteresting properties or those that you otherwise don't need to reference.

[source,javascript]
----
var names = ['James', 'L.', 'Howlett'];
var [ firstName,, lastName ] = names;
console.log(lastName);
// <- 'Howlett'
----

Array destructuring allows for default values just like object destructuring.

[source,javascript]
----
var names = ['James', 'L.'];
var [ firstName = 'John',, lastName = 'Doe' ] = names;
console.log(lastName);
// <- 'Doe'
----

In ES5, when you have to swap the values of two variables, you typically resort to a third, temporary variable, as in the following snippet.

[source,javascript]
----
var left = 5;
var right = 7;
var aux = left;
left = right;
right = aux;
----

Destructuring helps you avoid the +aux+ declaration and focus on your intent. Once again, destructuring helps us convey intent more tersely and effectively for the use case.

[source,javascript]
----
var left = 5;
var right = 7;
[left, right] = [right, left];
----

The last area of destructuring we'll be covering is function parameters.

==== 3.3.3 Destructuring Function Paremeters

Function parameters in ES6 enjoy the benefits of destructuring as well. One of the simplest cases is providing sensible default values. The following example defines a default +exponent+ with the most commonly used value.

[source,javascript]
----
function powerOf (base, exponent = 2) {
  return Math.pow(base, exponent);
}
----

Destructuring can be applied to arrow functions as well, but in that case you must wrap the parameters in parenthesis, even when there's a single parameter.

[source,javascript]
----
var double = (input = 0) => input * 2;
----

Given that this behaves like destructuring, default values aren't just limited to the rightmost parameters of a function. You could give default values to any parameter, in any position.

[source,javascript]
----
function sumOf (a = 1, b = 2, c = 3) {
  return a + b + c;
}
console.log(sumOf(undefined, undefined, 4));
// <- 1 + 2 + 4 = 7
----

In JavaScript it's not uncommon to provide a function with an +options+ object, containing several properties. You could determine a default +options+ object if one isn't provided, as shown in the next snippet.

[source,javascript]
----
function carFactory (options = { brand: 'Volkswagen', year: 1999 }) {
  console.log(options.brand);
  console.log(options.year);
}
carFactory();
// <- 'Volkswagen'
// <- 1999
----

The problem with this approach is that as soon as the consumer of +carFactory+ provides an +options+ object, you lose all of your defaults.

[source,javascript]
----
carFactory({ year: 2000 });
// <- undefined
// <- 2000
----

A better approach would be to destructure +options+ entirely, providing default values for each property individually. This approach also lets you reference each option without going through an +options+ object, but you lose the ability to reference +options+ directly, which might represent an issue in some situations.

[source,javascript]
----
function carFactory ({ brand = 'Volkswagen', year = 1999 }) {
  console.log(brand);
  console.log(year);
}
carFactory({ year: 2000 });
// <- 'Volkswagen'
// <- 2000
----

In this case, however, we've once again lost the default value for the case where the consumer didn't provide any +options+. Meaning +carFactory()+ will now throw when the +options+ aren't defined. This can be remedied by using the syntax shown in the following snippet of code, which adds a default +options+ value of an empty object. The empty object is then filled, property by property, with the default values on the parameter list.

[source,javascript]
----
function carFactory ({ brand = 'Volkswagen', year = 1999 } = {}) {
  console.log(brand);
  console.log(year);
}
carFactory();
// <- 'Volkswagen'
// <- 1999
----

Besides default values and filling an +options+ object, let's explore what else destructuring is good at.

==== 3.3.4 Use Cases for Destructuring

Whenever there's a function that returns an object or an array, destructuring makes it much terser to interact with. The following example shows a function that returns an object with some coordinates, where we grab only the ones we're interested in: +x+ and +y+. We're avoiding an intermediate +point+ variable declaration that often gets in the way without adding a lot of value to the readability of your code.

[source,javascript]
----
function getCoordinates () {
  return { x: 10, y: 22, z: -1, type: '3d' };
}
var { x, y } = getCoordinates();
----

The case for default option values bears repeating. Imagine you have a +random+ function which yields random integers between a +min+ and a +max+ value, and that it should default to values between 1 and 10. This is particularly interesting as an alternative to named parameters in other languages like Python and C#. This pattern, where you're able to define default values for options and then let consumers override them individually, offers great flexibility.

[source,javascript]
----
function random ({ min = 1, max = 10 } = {}) {
  return Math.floor(Math.random() * (max - min)) + min;
}
console.log(random());
// <- 7
console.log(random({ max: 24 }));
// <- 18
----

Regular expressions are another great fit for destructuring. Destructuring empowers you to name groups from a match without having to resort to index numbers. Here's an example +RegExp+ that could be used for parsing simple dates, and an example of destructuring those dates into each of its components. The first entry in the resulting array is reserved for the raw input string, and we can discard it.

[source,javascript]
----
function splitDate (date) {
  var rdate = /(\d+).(\d+).(\d+)/;
  return rdate.exec(date);
}
var [, year, month, day] = splitDate('2015-11-06');
----

Let's turn our attention to spread and rest operators next.

=== 3.4 Rest Parameters and Spread Operator

Before ES6, interacting with an arbitrary amount of function parameters was complicated. You had to use +arguments+, which isn't an array but has a +length+ property. Usually you'd end up casting the +arguments+ object into an actual array using +Array.prototype.slice.call+, and going from there, as shown in the following snippet.

[source,javascript]
----
function print () {
  var list = Array.prototype.slice.call(arguments);
  console.log(list);
}
print('a', 'b', 'c');
// <- ['a', 'b', 'c']
----

ES6 has a better solution to the problem, and that's rest parameters.

==== 3.4.1 Rest Parameters

You can now precede the last parameter in any JavaScript function with three dots, converting it into an special "rest parameter". When the rest parameter is the only parameter in a function, it gets all arguments passed to the function: it works just like the +.slice+ solution we saw earlier, but you avoid the need for a complicated construct like +arguments+, and it's specified in the parameter list.

[source,javascript]
----
function print (...list) {
  console.log(list);
}
print('a', 'b', 'c');
// <- ['a', 'b', 'c']
----

Named parameters before the rest parameter won't be included in the +list+.

[source,javascript]
----
function print (first ...list) {
  console.log(first);
  console.log(list);
}
print('a', 'b', 'c');
// <- 'a'
// <- [b', 'c']
----

Note that arrow functions with a rest parameter must include parenthesis, even when it's the only parameter. Otherwise, a +SyntaxError+ would be thrown. The following piece of code is a beautiful example of how combining arrow functions and rest parameters can yield concise functional expressions.

[source,javascript]
----
var sumAll = (...numbers) => numbers.reduce((total, next) => total + next);
console.log(sumAll(1, 2, 5));
// <- 8
----

Compare that with the ES5 version of the same function. Granted, it's all in the complexity. While terse, the +sumAll+ function can be confusing to readers unused to the +.reduce+ method, or because it uses two arrow functions. This is a complexity tradeoff that we'll cover in the second part of the book.

[source,javascript]
----
function sumAll () {
  var numbers = Array.prototype.slice.call(arguments);
  return numbers.reduce(function (a, b) {
    return a + b;
  });
}
console.log(sumAll(1, 2, 5));
// <- 8
----

Next up we have the spread operator. It's also denoted with three dots, but it serves a slightly different purpose.

==== 3.4.2 Spread Operator

The spread operator can be used to cast the an array-like object into a true array. Spreading effectively expands an expression onto a target such as an array literal or a function call. The following example uses +...arguments+ to cast function parameters into an array literal.

[source,javascript]
----
function cast () {
  return [...arguments];
}
cast('a', 'b', 'c');
// <- ['a', 'b', 'c']
----

You can place elements to the left and to the right of a spread operation and still get the result you would expect.

[source,javascript]
----
function cast () {
  return ['left', ...arguments, 'right'];
}
cast('a', 'b', 'c');
// <- ['left', 'a', 'b', 'c', 'right']
----

Spread is an useful way of combining multiple arrays. The following example shows how you can spread arrays anywhere into an array literal, expanding their elements into place.

[source,javascript]
----
var all = [1, ...[2, 3], 4, ...[5], 6, 7];
console.log(all);
// <- [1, 2, 3, 4, 5, 6, 7]
----

Note that the spread operator isn't limited to arrays and arraylikes such as +arguments+. The spread operator can be used with any iterable object. Iterable is a protocol in ES6 that allows you to turn any object into something that can be iterated over. We'll research the iterable protocol in chapter 4.

.Shifting and Spreading
****
When you want to extract an element or two from the beginning of an array, the common approach is to use +.shift+. While functional, the snippet of code below can be hard to understand at a glance, because it uses +.shift+ twice to grab a different item from the beginning of the +list+ each time. The focus is, like in many other pre-ES6 situations, placed on getting the language to do what we want.

[source,javascript]
----
var list = ['a', 'b', 'c', 'd', 'e'];
var first = list.shift();
var second = list.shift();
console.log(first);
// <- 'a'
----

In ES6, you can combine spread with array destructuring. The following piece of code is similar to the one above, except we're using a single line of code, and that single line is more descriptive of what we're doing that repeateadly calling +list.shift()+ in the previous example.

[source,javascript]
----
var [first, second, ...rest] = ['a', 'b', 'c', 'd', 'e'];
console.log(rest);
// <- ['c', 'd', 'e']
----

Using the spread operator you can focus on implementing the functionality you need while the language stays out of the way. Improving expressiveness and decreasing time spent working around language limitations is a common pattern we can observe in ES6 features.
****

Before ES6, whenever you have a dynamic list of arguments that need to be applied to a function call, you'll use +.apply+. This feels awkward because +.apply+ also takes a context for +this+, which most of the time you don't need to change.

[source,javascript]
----
func.apply(null, ['a', 'b', 'c']);
----

Besides spreading onto arrays, you can also spread items onto function calls. The following example shows how you could use the spread operator to pass an arbitrary number of arguments to the +multiply+ function.

[source,javascript]
----
function multiply (left, right) {
  return left * right;
}
var result = multiply(...[2, 3]);
console.log(result);
// <- 6
----

Spreading arguments onto a function call can be combined with regular arguments as much as necessary, just like with array literals. The next example calls +print+ with a coule of regular arguments and a couple of arrays being spread over the parameter list. Note how conveniently the rest +list+ parameter matches all the provided arguments. Spread and rest can help make code intent more clear without dilluting your codebase.

[source,javascript]
----
function print (...list) {
  console.log(list);
}
print(1, ...[2, 3], 4, ...[5])
// <- ['1', '2', '3', '4', '5']
----

Another limitation of +.apply+ is that combining it with the +new+ keyword, when instantiating an object, becomes very verbose. Here's an example of combining +new+ and +.apply+ to create a +Date+ object. Ignore for a moment that months in JavaScript dates are zero-based, turning +11+ into December, and consider how much of the following line of code is spent bending the language in our favor, just to instantiate a +Date+ object.

[source,javascript]
----
new (Date.bind.apply(Date, [null, 2015, 11, 31]))
// <- Thu Dec 31 2015
----

As shown in the next snippet, the spread operator strips away all the complexity and we're only left with the important bits. It's a +new+ instance, it uses +...+ to spread a dynamic list of arguments over the function call, and it's a +Date+. That's it.

[source,javascript]
----
new Date(...[2015, 11, 31])
// <- Thu Dec 31 2015
----

The following table summarizes the use cases we've discussed for the spread operator.

[options="header"]
|=======
|Use Case|ES5|ES6
|Concatenation|+[1, 2].concat(more)+|+[1, 2, ...more]+
|Push onto list|+list.push.apply(list, [3, 4])+|+list.push(...[3, 4])+
|Destructuring|+a = list[0], rest = list.slice(1)+ | +[a, ...rest] = list+
|+new+ and +apply+|+new (Date.bind.apply(Date, [null,2015,31,8]))+| +new Date(...[2015,31,8])+
|=======

Next up, another interesting addition to the language. Template literals are a new way to define strings.

=== 3.5 Template Literals

Template literals are a vast improvement upon regular JavaScript strings. Instead of using single or double quotes, template literals are declared using backticks, as shown next.

[source,javascript]
----
var text = `This is my first template literal`;
----

Given that template literals are delimited by backticks, you're now able to declare strings with both +'+ and +"+ quotation marks in them without having to escape either, as shown below.

[source,javascript]
----
var text = `I'm "amazed" at these opportunities!`;
----

One of the most appealing features of template literals is their ability to interpolate JavaScript expressions.

==== 3.5.1 String Interpolation

With template literals, you're able to interpolate any JavaScript expressions inside your templates. When the template literal expression is reached, it's evaluated and you get back the compiled result. The following example interpolates a +name+ variable into a template literal.

[source,javascript]
----
var name = 'Shannon';
var text = `Hello, ${name}!`;
console.log(text);
// <- 'Hello, Shannon!'
----

We've already established that you can use any JavaScript expressions, and not just variables. You can think of the expressions in a template literal as defining a variable before the template runs, and then concatenating that value with the rest of the string, but in an easier to maintain format that doesn't involve you manually adding strings together with expressions. The variables you use in those expressions, the functions you call, and so on, should all be available to the current scope.

It will be up to your coding style guides to decide how much logic you want to cram into the interpolation expressions. The following code snippet, for example, instantiates a +Date+ object and formats it into a human-readable date inside a template literal.

[source,javascript]
----
`The time and date is ${new Date().toLocaleString()}.`
// <- 'the time and date is 8/26/2015, 3:15:20 PM'
----

You could interpolate mathematical operations.

[source,javascript]
----
`The result of 2+3 equals ${2+3}`
// <- 'The result of 2+3 equals 5'
----

You could even nest template literals, as they are also valid JavaScript expressions.

[source,javascript]
----
`This a template literal ${`with another ${'one'} embedded inside it`}`
// <- 'This a template literal with another one embedded inside it'
----

Another perk of template literals is their multiline string representation support.

==== 3.5.2 Multiline Template Literals

Before template literals, if you wanted to represent strings in multiple lines of JavaScript, you had to resort to escaping, concatenation, arrays, or even ellaborate hacks using comments. The following snippet summarizes some of the most common ways multiline string representations prior to ES6.

[source,javascript]
----
var escaped =
'The first line\n\
A second line\n\
Then a third line';

var concatenated =
'The first line\n' +
'A second line\n' +
'Then a third line';

var joined = [
'The first line',
'A second line',
'Then a third line'
].join('\n');
----

Under ES6, you could use backticks instead. Template literals support multiline strings by default. Note how there's no +\n+ escapes, no concatenation, and no arrays involved.

[source,javascript]
----
var multiline =
`The first line
A second line
Then a third line`;
----

Multiline strings really shine when you have, for instance, a chunk of HTML you want to interpolate some variables into. If you need to display a list within the template, you could iterate the list, mapping its items into the corresponding markup, and then return the joined result from an interpolated expression. This makes it a breeze to declare subcomponents within your templates, as shown in the following piece of code.

[source,javascript]
----
var book = {
  title: 'Modular ES6',
  excerpt: 'Here goes some properly sanitized HTML',
  tags: ['es6', 'template-literals', 'es6-in-depth']
};
var html = `<article>
  <header>
    <h1>${book.title}</h1>
  </header>
  <section>${book.excerpt}</section>
  <footer>
    <ul>
      ${
        book.tags
          .map(tag => `<li>${tag}</li>`)
          .join('\n      ')
      }
    </ul>
  </footer>
</article>`;
----

The template we've just prepared would produce output like what's shown in the following snippet of code. Note how spacing was preserved, and how +<li>+ tags are properly indented thanks for how we joined them together using a few spaces.

[source,html]
----
<article>
  <header>
    <h1>Modular ES6</h1>
  </header>
  <section>Here goes some properly sanitized HTML</section>
  <footer>
    <ul>
      <li>es6</li>
      <li>template-literals</li>
      <li>es6-in-depth</li>
    </ul>
  </footer>
</article>
----

Sometimes, it might be a good idea to pre-process the results of expressions before inserting them into your templates. For these advanced kinds of use cases, it's possible to use another feature of template literals called tagged templates.

==== 3.5.3 Tagged Templates

By default, JavaScript interprets +\+ as an escape character with special meaning. For example, +\n+ is interpreted as a newline, +\u00f1+ is interpreted as +ñ+, etcetera. You could avoid these rules using the +String.raw+ tagged template. The next snippet shows a template literal using +String.raw+ which prevents +\n+ from being interpreted as a newline.

[source,javascript]
----
var text = String.raw`The "\n" newline won't result in a new line.
It'll be escaped.`;
console.log(text);
// The "\n" newline won't result in a new line.
// It'll be escaped.
----

The +String.raw+ prefix we've added to our template literal is a tagged template. It's used to parse the template. Tagged templates receive a parameter with an array containing the static parts of the template, as well as the result of evaluating each expression, each in its own parameter.

A template literal like +`Hello, ${name}. I am ${emotion} to meet you!`+, for instance, will invoke a tagged template +tag+ using the following parameters.

[source,javascript]
----
tag(['Hello, ', '. I am ', ' to meet you!'], 'Maurice', 'thrilled');
----

The template is built by taking each part of the template and placing one of the expressions next to it, until there's no more parts of the template left. It might be hard to interpret the argument list without looking at a potential implementation of the default template literal +tag+, so let's do that.

The following snippet of code shows a possible implementation of the default +tag+. It provides the same functionality as a template literal does when a tagged template isn't explicitly provided. It reduces the +parts+ array into a single value, the result of evaluating the template literal. The result is initialized with the first +part+, and then each other +part+ of the template is preceded by one of the +values+. We've used the rest parameter syntax for +...values+ in order to make it easier to grab the result of evaluating each expression in the template. We're using an arrow function with an implicit +return+ statement, given that its expression is relatively simple.

[source,javascript]
----
function tag (parts, ...values) {
  return parts.reduce(
    (all, part, i) => all + values[i - 1] + part
  );
}
----

You can try the +tag+ template using code like in the following snippet. You'll notice you get the same output as if you omitted +tag+, since we're copying the default behavior.

[source,javascript]
----
var name = 'Maurice';
var emotion = 'thrilled';
var text = tag`Hello, ${name}. I am ${emotion} to meet you!`;
console.log(text)
// <- 'Hello Maurice, I am thrilled to meet you!'
----

Multiple use cases apply to tagged templates. One possible use case might be to make user input uppercase, making the string sound satirical. That's what the following piece of code does. We've modified +tag+ slightly so that any interpolated strings are uppercased.

[source,javascript]
----
function upper (parts, ...values) {
  return parts.reduce(
    (all, part, i) => all + values[i - 1].toUpperCase() + part
  );
}
var name = 'Maurice';
var emotion = 'thrilled';
var text = upper`Hello, ${name}. I am ${emotion} to meet you!`;
console.log(text);
// <- 'Hello MAURICE, I am THRILLED to meet you!'
----

A decidedly more useful use case would be to sanitize expressions interpolated into your templates, automatically, using a tagged template. Given a template where all expressions are considered user-input, we could use a hypothetical +sanitize+ library to remove HTML tags and similar hazards.

[source,javascript]
----
function sanitized (parts, ...values) {
  return parts.reduce(
    (all, part, i) => all + sanitize(values[i - 1]) + part
  );
}
var comment = 'A malicious comment<iframe src="http://evil.corp"></iframe>';
var html = sanitized`<div>${comment}</div>`;
console.log(html);
// <- '<div>A malicious comment</div>'
----

Phew, that malicious +<iframe>+ almost got us. Rounding out ES6 syntax changes, we have the +let+ and +const statements.

=== 3.6 Let and Const Statements

The +let+ statement is one of the most well-known features in ES6. It works like a +var+ statement, but it has different scoping rules.

JavaScript has always had a complicated ruleset when it comes to scoping, driving many programmers crazy when they were first trying to figure out how variables work in JavaScript. Eventually, you discover hoisting, and JavaScript starts making a bit more sense to you. Hoisting means that variables get pulled from anywhere they were declared in user code to the top of their scope. For example, see the code below.

[source,javascript]
----
function isItTwo (value) {
  if (value === 2) {
    var two = true;
  }
  return two;
}
isItTwo(2);
// <- true
isItTwo('two');
// <- undefined
----

JavaScript code like this works, even though +two+ was declared in a code branch and then accessed outside of said branch. The reason why, as we know, is that +var+ is function-scoped. That, coupled with hoisting, means that what we're really expressing is equivalent to the piece of code below.

[source,javascript]
----
function isItTwo (value) {
  var two;
  if (value === 2) {
    two = true;
  }
  return two;
}
----

Whether we like it or not, hoisting is more confusing than having block-scoped variables would be. Block scoping works on the bracket level, rather than the function level.

==== 3.6.1 Block Scoping and Let Statements

Instead of having to declare a new +function+ if we want a deeper scoping level, block scoping allows you to just leverage existing code branches like those in +if+, +for+, or +while+ statements; you could also create new +{}+ blocks arbitrarily. As you may or may not know, the JavaScript language allows us to create an indiscriminate number of blocks, just because we want to.

[source,javascript]
----
{{{{{ var deep = 'This is available from outer scope.'; }}}}}
console.log(deep);
// <- 'This is available from outer scope.'
----

With +var+, because of lexical scoping, one could still access the +deep+ variable from outside those blocks, and not get an error. Sometimes it can be very useful to get errors in these situations. Particularly if one or more of the following is true.

- Accessing the inner variable breaks some sort of encapsulation principle in our code
- The inner variable doesn't belong in the outer scope at all
- The block in question has many siblings that would also want to use the same variable name
- One of the parent blocks already has a variable with the name we need, but the name is still appropriate to use in the inner block

The +let+ statement is an alternative to +var+. It follows block scoping rules instead of the default lexical scoping rules. With +var+, the only way of getting a deeper scope is to create a nested function, but with +let+ you can just open another pair of brackets. This means you don't need entirely new functions to get a new scope: a simple +{}+ block will do.

[source,javascript]
----
let topmost = {};
{
  let inner = {};
  {
    let innermost = {};
  }
  // attempts to access innermost here would throw
}
// attempts to access inner here would throw
// attempts to access innermost here would throw
----

An useful aspect of +let+ statements is that you can use them when declaring a +for+ loop, and variables will be scoped to the contents of the loop, as shown below.

[source,javascript]
----
for (let i = 0; i < 2; i++) {
  console.log(i);
  // <- 0
  // <- 1
}
console.log(i);
// <- i is not defined
----


One more thing of note about +let+ is a concept called the "Temporal Dead Zone".

==== 3.6.2 Temporal Dead Zone

In so many words: if you have code such as the following code snippet, it'll throw. Once execution enters a scope, and until a +let+ statement is reached, attempting to access the variable for said +let+ statement will throw. This is known as the Temporal Dead Zone (TDZ).

[source,javascript]
----
{
  name = 'Barbara Penner';
  // <- ReferenceError: name is not defined
  let name = 'Stephen Hawking';
}
----

If your code tries to access +name+ in any way before the +let name+ statement is reached, the program will throw. Declaring a function that references +name+ before it's defined is okay, as long as the function doesn't get executed while +name+ is in the TDZ, and +name+ will be in the TDZ until the +let name+ statement is reached. This snippet won't throw because +return name+ isn't executed until after +name+ leaves the TDZ.

[source,javascript]
----
function readName () {
  return name;
}
let name = 'Stephen Hawking';
console.log(readName());
// <- 'Stephen Hawking'
----

But the following snippet will, because access to +name+ occurs before leaving the TDZ for +name+.

[source,javascript]
----
function readName () {
  return name;
}
console.log(readName());
// ReferenceError: name is not defined
let name = 'Stephen Hawking';
----

Note that the semantics for these examples doesn't change when +name+ isn't actually assigned a value when initially declared. The next snippet throws as well, as it still tries to access +name+ before leaving the TDZ.

[source,javascript]
----
function readName () {
  return name;
}
console.log(readName());
// ReferenceError: name is not defined
let name;
----

The following bit of code works because it leaves the TDZ before accessing +name+ in any way.

[source,javascript]
----
function readName () {
  return name;
}
let name;
console.log(readName());
// <- undefined
----

The only tricky part to remember is that it's okay to declare functions that access a variable in the TDZ as long as the statements accessing TDZ variables aren't reached before the +let+ declaration is reached.

The whole point of the TDZ is to make it easier to catch errors where accessing a variable before it's declared in user code leads to unexpected behavior. This happened a lot before ES6 due both to hoisting and poor coding conventions. In ES6 it's easier to avoid. Keep in mind that hoisting still applies for +let+ as well. That means variables will be created when we enter the scope, and the TDZ will be born, but they will be inaccessible until code execution hits the place where the variable was actually declared, at which point we leave the TDZ and are allowed to access the variable.

We made it through the temporal dead zone! It's now time to cover +const+, a similar statement to +let+ but with a few major differences.

==== 3.6.3 Const Statements

The +const+ statement is block scoped like +let+, and it follows TDZ semantics as well. In fact, TDZ semantics were implemented because of +const+, and then TDZ was also applied to +let+ for consistency. The reason why +const+ needed TDZ semantics is that it would otherwise have been possible to assign a value to a hoisted +const+ variable before reaching the +const+ declaration, meaning that the declaration itself would throw. The temporal dead zone defines a solution that solves the problem of making +const+ assignment possible only at declaration time, helps avoid potential issues when using +let+, and also makes it easy to eventually implement other features that benefit from TDZ semantics.

The following snippet shows how +const+ follows block scoping rules exactly like +let+.

[source,javascript]
----
const pi = 3.1415;
{
  const pi = 6;
  console.log(pi);
  // <- 6
}
console.log(pi);
// <- 3.1415
----

We've mentioned major differences between +let+ and +const+. The first one is that +const+ variables must be declared using an initializer. A +const+ declaration must be accompanied by an initializer, as shown in the following snippet.

[source,javascript]
----
const pi = 3.1415;
const e; // SyntaxError, missing initializer
----

Besides the assignment when initializing a +const+, variables declared using a +const+ statement can't be assigned to. Once a +const+ is initialized, you can't change its value. Under strict mode, attempts to change a +const+ variable will throw. Outside of strict mode, they'll fail silently as demonstrated by the following piece of code.

[source,javascript]
----
const people = ['Tesla', 'Musk'];
people = [];
console.log(people);
// <- ['Tesla', 'Musk']
----

Creating a +const+ variable doesn't mean that the assigned value becomes immutable, it only means that the variable will always have a reference to the same object or primitive value. The following example shows that even though the +people+ reference couldn't be changed, the array itself can indeed be modified.

[source,javascript]
----
const people = ['Tesla', 'Musk'];
people.push('Berners-Lee');
console.log(people);
// <- ['Tesla', 'Musk', 'Berners-Lee'];
----

A +const+ statement only prevents the variable being declared from changing its value. Another way of representing that difference is the following piece of code, where we create a +humans+ variable using +var+, assign the +people+ variable we created using +const+ earlier, and then assign something else to the +humans+ variable, because it wasn't declared using +const+.

[source,javascript]
----
const people = ['Tesla', 'Musk'];
var humans = people;
humans = 'evil';
console.log(humans);
// <- 'evil';
----

Let's take a moment to discuss the merits of +const+ and +let+.

==== 3.6.4 Merits of Const and Let

New features should never be used for the sake of using new features. ES6 features should be used where they genuinely improve code readability and maintainability. The +let+ statement is able to, in many cases, simplify pieces of code where you'd otherwise declare +var+ statements at the top of a function just so that hoisting doesn't produce unexpected results. Using the +let+ statement you'd be able to place your declarations at the top of a code block, instead of the top of the whole function, reducing the latency in mental trips to the top of the scope.

Using the +const+ statement is a great way to prevent accidents. The following piece of code is an plausably error prone scenario where we pass of a reference to an +items+ variable to a +checklist+ function which then returns a +todo+ API that in turn interacts with said +items+ reference. When the +items+ variable is changed to reference another list of items, we're in for a world of hurt: the +todo+ API still works with the value +items+ used to have, but +items+ is referencing something else now.

[source,javascript]
----
var items = ['a', 'b', 'c'];
var todo = checklist(items);
todo.check();
console.log(items);
// <- ['b', 'c']
items = ['d', 'e'];
todo.check();
console.log(items);
// <- ['d', 'e'], would be ['c'] if items had been constant
function checklist (items) {
  return {
    check: () => items.shift()
  };
}
----

This type of problem is hard to debug because it might take a while until you figure out that the reference was modified. The +const+ statement helps prevent this scenario by producing a runtime error (under strict mode), which should help capture the bug soon after it's introduced.

A similar benefit of using the +const+ statement is its ability to visually identify variables that aren't reassigned. The +const+ cue signals that a variable is read-only and thus we have one less thing to worry about when reading a piece of code.

If we choose to default to using +const+ and use +let+ for variables that need to be reassigned, all variables will follow the same scoping rules, which makes code easier to reason about. The reason why +const+ is sometimes proposed as the "default" variable declaration type, is that it's the one that does the least: +const+ prevents reassignment, follows block scoping, and the declared binding can't be accessed before the declaration statement is executed. The +let+ statement allows reassignment, but behaves like +const+, so it naturally follows to choose +let+ when we're in need for a reassignable variable.

On the counterside, +var+ is a more complex declaration because it is hard to use in code branches due to function scoping rules, it allows reassignment, and it can be accessed before the declaration statement is reached. The +var+ statement is inferior to +const+ and +let+, which do less, and is thus less prominent in modern JavaScript codebases.

Throughout this book, we'll follow the practice of using +const+ by default and +let+ when reassignment is desirable.

In the following chapter we'll look at more features coming in ES6 and how they can be used to iterate over any JavaScript objects, as well as how to master flow control using promises and generators.
